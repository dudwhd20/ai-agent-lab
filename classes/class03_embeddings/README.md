# Class 02 – Memory (상태를 가지는 Agent)

Class 02에서는 Agent가 이전 요청을 전혀 기억하지 못하는 문제를 해결하기 위해  
**상태(Memory)를 코드로 관리하는 구조**를 직접 구현했습니다.

LangChain의 대화용 Memory가 아니라,  
**의사결정에 영향을 주는 상태**를 어떻게 다뤄야 하는지에 초점을 맞췄습니다.

---

## 🎯 목표

- 같은 질문이 반복될 때 Agent 행동이 달라지도록 만들기
- “기억”을 LLM이 아니라 **코드가 책임지도록 구조 변경**
- 반복 요청 시 불필요한 LLM 호출 줄이기

---

## Class 02에서 다룬 핵심 문제

### Class01에서 드러난 한계

- 같은 질문을 여러 번 해도:
  - 매번 KB 재검색
  - 매번 동일한 1차 점검 가이드 출력
  - 이전에 이미 안내했다는 인식이 전혀 없음
- Agent는 사실상 **항상 처음 보는 요청처럼 행동**

---

## 일반적으로 알려진 정답 구조

- LLM은 기본적으로 **무상태(stateless)**
- 따라서 실무에서는:
  - “기억”을 LLM에게 맡기지 않음
  - 별도의 상태 저장소(Memory)를 두고
  - **분기 판단은 코드가 담당**

역할 분리 관점에서의 정답은 다음과 같음:
