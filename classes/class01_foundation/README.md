# Class 01 – Agent Foundation (Class 1-B 까지)

이 Class에서는 LangChain 기반 Agent의 기본 구조를 직접 구현해보고,  
Tool 호출과 응답 흐름을 관찰하면서 **Agent 제어의 필요성**을 체감하는 데 초점을 두었습니다.

단순히 “Agent를 만들어봤다” 수준이 아니라,  
직접 겪은 문제와 함께 **일반적으로 알려진 정답 구조**를 같이 정리했습니다.

---

## 전체 목표

- Agent의 기본 동작 흐름 이해 (ReAct)
- Tool 호출이 실제로 어떻게 발생하는지 확인
- Agent 응답 품질이 왜 흔들리는지 경험
- 이 문제를 **실무에서는 어떻게 해결하는지**까지 같이 정리

---

## Class 1-A: Agent 기본 흐름

### 해본 것

- LangChain `create_agent` 기반 Agent 구성
- ReAct 패턴 기반 동작 흐름 확인
  - Reason → Action → Observation → Final
- Tool(`search_kb`, `create_ticket`) 호출 로그 확인
- `agent.invoke()` 결과가 메시지 체인(`messages[]`)으로 반환되는 구조 이해

### 느낀 점

- Agent는 “한 번에 답을 만드는 구조”가 아님
- 내부적으로는:
  - Tool 호출 판단
  - Tool 실행 결과 반영
  - 최종 답변 생성
    을 여러 메시지로 나눠서 처리함
- 우리가 보는 최종 답은 이 중 **마지막 AIMessage 하나**일 뿐임

---

## Class 1-B: Agent 제어와 응답 품질

Class 1-A 단계에서는 Agent가 “동작”은 했지만,  
실제로 사용하기에는 몇 가지 문제가 바로 드러났습니다.

---

### 1️⃣ KB 결과가 없으면 바로 티켓을 만들어버리는 문제

#### 실제로 겪은 문제

- KB 검색 결과가 없으면 곧바로 티켓 생성
- 사용자 입장에서는 너무 기계적이고 성급한 응답처럼 보임

#### 내가 한 접근

- KB 결과 유무와 상관없이
  - 항상 **1차 점검 가이드**를 먼저 안내
  - 그 이후에만 티켓 생성 고려

#### 일반적으로 알려진 정답 구조

- Agent는 “최종 조치자”가 아니라 **1차 응대 역할**로 두는 게 일반적
- 즉,
  - 정보 제공 / 가이드 → 사람이 개입
    흐름이 자연스러움

---

### 2️⃣ Tool 호출 시 LLM이 query를 임의로 바꾸는 문제

#### 실제로 겪은 현상

동일한 사용자 입력임에도, Tool 호출 시 LLM이 다음과 같이 **query를 바꿔서 호출**하는 경우를 여러 번 확인함.

예:

- 사용자 입력: `카카오톡 알림 안 옴`
- Tool 호출 query:
  - `화면이 안 나옴`
  - `사내 인터넷 차단 해제 요청`
  - `팀 메신저 알림 안 옴`

즉, LLM이 사용자 입력을 그대로 쓰지 않고  
**문제를 재해석해서 Tool을 호출**함.

---

### 3️⃣ 이 문제를 통해 알게 된 구조적 한계

#### 직접 느낀 점

- Tool의 입력 값(args)은 **전부 LLM이 만든다**
- 따라서 Tool 인자에 “신뢰해야 하는 값”을 그대로 맡기면 위험함
- Agent가 똑똑해질수록, 오히려 문제를 바꿔버릴 가능성이 있음

#### 일반적으로 알려진 정답

- **신뢰해야 하는 데이터는 LLM에게 맡기지 않는다**
- 사용자 원문, 세션 정보, 보안 관련 값은
  - 코드 또는 상태(State)가 보유
  - LLM은 참고만 하도록 설계

즉:

- LLM → 판단/추론
- 코드 → 사실/상태 관리  
  이 역할 분리가 중요함

---

### 4️⃣ 이 단계에서의 결론

Class 1-B까지 진행하면서 느낀 결론은 단순합니다.

- ReAct 구조나 Tool 호출 자체는 이제 “기본 기능”
- 진짜 어려운 부분은
  - Agent가 **어디까지 판단하게 할지**
  - 어디부터는 **코드로 강제할지**
- 이 경계가 없으면 응답 품질과 일관성이 쉽게 무너짐

이 문제를 해결하려면:

- 사용자 입력을 상태로 관리하거나
- Tool 호출 전에 값을 보정하거나
- Agent 흐름 자체를 구조화할 필요가 있음

이게 다음 Class로 넘어가게 된 이유입니다.

---

## 다음 단계 예고

- 같은 질문을 반복했을 때 매번 다른 판단을 하는 문제
- 이전 안내 내용을 기억하지 못하는 문제
- Tool 호출을 제어하기 어려운 구조적 한계

이 문제를 해결하기 위해  
다음 Class에서는 **Memory(상태 관리)**를 다룰 예정입니다.
